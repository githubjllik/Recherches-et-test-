<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formulaire Immersif avec Araignée</title>
    <style>
        :root {
            --primary-color: #7289da;
            --secondary-color: #5865f2;
            --background-dark: #1e1e2e;
            --card-dark: #2a2a3a;
            --text-light: #f0f0f0;
            --text-dim: #a0a0a0;
            --border-radius: 10px;
            --folder-color: #ffca28;
            --app-shadow: 0 8px 16px rgba(0,0,0,0.2);
            --transition-speed: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-dark);
            color: var(--text-light);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #iconsCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .web-icons {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .web-icon {
            position: absolute;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--card-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--app-shadow);
            transform: scale(0);
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        opacity 0.5s ease-in-out;
        }

        .web-icon.visible {
            transform: scale(1);
            opacity: 1;
        }

        .web-icon img {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }

        .spider-web {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .web-line {
            position: absolute;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            transform-origin: left center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, background-color 0.3s ease-in-out;
        }

        .web-line.visible {
            opacity: 1;
        }

        .web-line.highlight {
            background-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            height: 1.5px;
        }

.login-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 320px;
    background-color: var(--card-dark);
    border-radius: var(--border-radius);
    padding: 2rem;
    box-shadow: var(--app-shadow);
    z-index: 3;
    opacity: 0;
}

        .login-title {
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            height: 36px;
            overflow: hidden;
        }

        .login-title span {
            display: inline-block;
            opacity: 0;
            transform: translateY(20px);
        }

        .form-group {
            margin-bottom: 1.5rem;
            opacity: 0;
            transform: translateY(20px);
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-dim);
        }

        .input-wrapper {
            position: relative;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            color: var(--text-light);
            font-size: 1rem;
            transition: var(--transition-speed);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: rgba(255, 255, 255, 0.15);
        }

        .password-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            opacity: 0;
        }

        .password-toggle svg {
            width: 20px;
            height: 20px;
        }

        .login-button {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--primary-color);
            border: none;
            border-radius: var(--border-radius);
            color: var(--text-light);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-speed);
            opacity: 0;
            transform: translateY(20px);
        }

        .login-button:hover {
            background-color: var(--secondary-color);
        }

.spider {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 120px;
    z-index: 10;
}

.spider-body {
    position: absolute;
    top: 40px;
    left: 30px;
    width: 40px;
    height: 60px;
    background-color: #222;
    border-radius: 50%;
}

.spider-head {
    position: absolute;
    top: 20px;
    left: 35px;
    width: 30px;
    height: 30px;
    background-color: #111;
    border-radius: 50%;
}

.spider-eyes {
    position: absolute;
    top: 5px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: center;
}

.spider-eye {
    position: relative;
    width: 12px;
    height: 12px;
    background-color: white;
    border-radius: 50%;
    margin: 0 2px;
}

.spider-pupil {
    position: absolute;
    width: 6px;
    height: 6px;
    background-color: black;
    border-radius: 50%;
    top: 3px;
    left: 3px;
}

.spider-leg {
    position: absolute;
    width: 40px;
    height: 4px;
    background-color: #222;
    border-radius: 4px;
}

.leg-1 {
    top: 35px;
    left: 5px;
    transform: rotate(45deg);
}

.leg-2 {
    top: 45px;
    left: 5px;
    transform: rotate(20deg);
}

.leg-3 {
    top: 55px;
    left: 5px;
    transform: rotate(-20deg);
}

.leg-4 {
    top: 65px;
    left: 5px;
    transform: rotate(-45deg);
}

.leg-5 {
    top: 35px;
    right: 5px;
    transform: rotate(-45deg);
}

.leg-6 {
    top: 45px;
    right: 5px;
    transform: rotate(-20deg);
}

.leg-7 {
    top: 55px;
    right: 5px;
    transform: rotate(20deg);
}

.leg-8 {
    top: 65px;
    right: 5px;
    transform: rotate(45deg);
}

.spider-thread {
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 30px;
    background-color: rgba(255, 255, 255, 0.3);
}

.web-shot {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.4);
    transform-origin: top left;
    pointer-events: none;
    z-index: 4;
    opacity: 0;
}

.camera-web {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
    background-size: 30px 30px;
    pointer-events: none;
    opacity: 0;
    z-index: 999;
    transition: opacity 0.3s ease;
}

.login-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 320px;
    background-color: var(--card-dark);
    border-radius: var(--border-radius);
    padding: 2rem;
    box-shadow: var(--app-shadow);
    z-index: 3;
    opacity: 0;
}


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .login-container {
                width: 90%;
                max-width: 320px;
                padding: 1.5rem;
            }

            .spider {
                width: 80px;
                height: 100px;
            }

            .spider-body {
                top: 35px;
                left: 25px;
                width: 30px;
                height: 45px;
            }

            .spider-head {
                top: 15px;
                left: 25px;
                width: 25px;
                height: 25px;
            }

            .spider-eye {
                width: 10px;
                height: 10px;
            }

            .spider-pupil {
                width: 5px;
                height: 5px;
                top: 2.5px;
                left: 2.5px;
            }

            .spider-leg {
                width: 30px;
                height: 3px;
            }
        }

        @media (min-width: 1200px) {
            .login-container {
                width: 380px;
                padding: 2.5rem;
            }

            .spider {
                width: 120px;
                height: 140px;
            }

            .spider-body {
                top: 45px;
                left: 35px;
                width: 50px;
                height: 70px;
            }

            .spider-head {
                top: 25px;
                left: 40px;
                width: 35px;
                height: 35px;
            }

            .spider-eye {
                width: 14px;
                height: 14px;
            }

            .spider-pupil {
                width: 7px;
                height: 7px;
                top: 3.5px;
                left: 3.5px;
            }

            .spider-leg {
                width: 50px;
                height: 5px;
            }
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid var(--primary-color);
            border-bottom-color: transparent;
            border-radius: 50%;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Cercles concentriques pour donner de la profondeur */
        .web-circle {
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loader"></div>
    </div>
    
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="iconsCanvas"></canvas>
    
    <div class="web-icons" id="webIcons"></div>
    <div class="spider-web" id="spiderWeb"></div>
    <div class="camera-web" id="cameraWeb"></div>
    
    <div class="login-container" id="loginContainer">
        <h2 class="login-title" id="loginTitle">
            <span>C</span><span>o</span><span>n</span><span>n</span><span>e</span><span>x</span><span>i</span><span>o</span><span>n</span>
        </h2>
        <div class="form-group" id="usernameGroup">
            <label for="username">Nom d'utilisateur</label>
            <div class="input-wrapper">
                <input type="text" id="username" class="form-control" placeholder="Entrez votre identifiant">
            </div>
        </div>
        <div class="form-group" id="passwordGroup">
            <label for="password">Mot de passe</label>
            <div class="input-wrapper">
                <input type="password" id="password" class="form-control" placeholder="Entrez votre mot de passe">
                <button type="button" class="password-toggle" id="passwordToggle">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
            </div>
        </div>
        <button type="button" class="login-button" id="loginButton">Se connecter</button>
    </div>

    <div class="spider" id="spider">
        <div class="spider-thread"></div>
        <div class="spider-head">
            <div class="spider-eyes">
                <div class="spider-eye">
                    <div class="spider-pupil" id="leftPupil"></div>
                </div>
                <div class="spider-eye">
                    <div class="spider-pupil" id="rightPupil"></div>
                </div>
            </div>
        </div>
        <div class="spider-body"></div>
        <div class="spider-leg leg-1"></div>
        <div class="spider-leg leg-2"></div>
        <div class="spider-leg leg-3"></div>
        <div class="spider-leg leg-4"></div>
        <div class="spider-leg leg-5"></div>
        <div class="spider-leg leg-6"></div>
        <div class="spider-leg leg-7"></div>
        <div class="spider-leg leg-8"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // ===========================================
            // DÉFINITION DES CONSTANTES ET VARIABLES PRINCIPALES
            // ===========================================
            
            // Éléments DOM
            const spider = document.getElementById('spider');
            const loginContainer = document.getElementById('loginContainer');
            const loginTitle = document.getElementById('loginTitle');
            const titleSpans = loginTitle.querySelectorAll('span');
            const usernameGroup = document.getElementById('usernameGroup');
            const passwordGroup = document.getElementById('passwordGroup');
            const loginButton = document.getElementById('loginButton');
            const passwordToggle = document.getElementById('passwordToggle');
            const password = document.getElementById('password');
            const username = document.getElementById('username');
            const leftPupil = document.getElementById('leftPupil');
            const rightPupil = document.getElementById('rightPupil');
            const spiderWeb = document.getElementById('spiderWeb');
            const webIcons = document.getElementById('webIcons');
            const cameraWeb = document.getElementById('cameraWeb');
            const loadingScreen = document.getElementById('loadingScreen');
            
            // Canvas pour le fond et les icônes
            const backgroundCanvas = document.getElementById('backgroundCanvas');
            const iconsCanvas = document.getElementById('iconsCanvas');
            const bgCtx = backgroundCanvas.getContext('2d');
            const iconCtx = iconsCanvas.getContext('2d');
            
            // Ajuster la taille des canvas
            function resizeCanvases() {
                backgroundCanvas.width = window.innerWidth;
                backgroundCanvas.height = window.innerHeight;
                iconsCanvas.width = window.innerWidth;
                iconsCanvas.height = window.innerHeight;
            }
            
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Centres et dimensions
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // ===========================================
            // DÉFINITION DES ICÔNES
            // ===========================================
            
            // Sites web principaux
            const websites = [
                'google.com', 'youtube.com', 'tiktok.com', 'facebook.com', 
                'github.com', 'twitter.com', 'telegram.org', 'poe.com', 
                'reddit.com', 'openai.com', 'instagram.com', 'linkedin.com',
                'dropbox.com', 'netflix.com', 'apple.com', 'microsoft.com',
                'amazon.com', 'spotify.com', 'twitch.tv', 'pinterest.com',
                'discord.com', 'slack.com', 'adobe.com', 'zoom.us'
            ];
            
            // Collection d'icônes définies manuellement
            // Structure : {type, name, color, svgPath}
            
            // Icônes des dossiers
            const folderIcons = [
                { type: 'folder', name: 'Dossier', color: '#FFD54F', 
                  svgPath: 'M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z' },
                { type: 'folder', name: 'Dossier ouvert', color: '#FFD54F', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z' },
                { type: 'folder', name: 'Téléchargements', color: '#4FC3F7', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6 12l-6-6h4V8h4v4h4l-6 6z' },
                { type: 'folder', name: 'Images', color: '#FF8A65', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-2 6l-3 3.72L13 14l-3 4h10V12z' },
                { type: 'folder', name: 'Vidéos', color: '#BA68C8', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 6l-7 4V8l7 4z' },
                { type: 'folder', name: 'Musique', color: '#7986CB', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-2 10h-3v3h-2v-3h-3v-2h3v-3h2v3h3v2z' },
                { type: 'folder', name: 'Documents', color: '#AED581', 
                  svgPath: 'M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z' },
                { type: 'folder', name: 'Sécurité', color: '#FF8A65', 
                  svgPath: 'M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-4 10h-2v2h-4v-2H8v-4h2v-2h4v2h2v4z' }
            ];
            
            // Icônes des systèmes d'exploitation
            const osIcons = [
                { type: 'os', name: 'Windows', color: '#0078D6', 
                  svgPath: 'M0,0 L9,0 L9,9 L0,9 L0,0 Z M10,0 L21,0 L21,9 L10,9 L10,0 Z M0,10 L9,10 L9,21 L0,21 L0,10 Z M10,10 L21,10 L21,21 L10,21 L10,10 Z' },
                { type: 'os', name: 'Apple', color: '#999999', 
                  svgPath: 'M18.71,19.5C17.88,20.74 17,21.95 15.66,21.97C14.32,22 13.89,21.18 12.37,21.18C10.84,21.18 10.37,21.95 9.1,22C7.79,22.05 6.8,20.68 5.96,19.47C4.25,17 2.94,12.45 4.7,9.39C5.57,7.87 7.13,6.91 8.82,6.88C10.1,6.86 11.32,7.75 12.11,7.75C12.89,7.75 14.37,6.68 15.92,6.84C16.57,6.87 18.39,7.1 19.56,8.82C19.47,8.88 17.39,10.1 17.41,12.63C17.44,15.65 20.06,16.66 20.09,16.67C20.06,16.74 19.67,18.11 18.71,19.5M13,3.5C13.73,2.67 14.94,2.04 15.94,2C16.07,3.17 15.6,4.35 14.9,5.19C14.21,6.04 13.07,6.7 11.95,6.61C11.8,5.46 12.36,4.26 13,3.5Z' },
                { type: 'os', name: 'Linux', color: '#FCC624', 
                  svgPath: 'M12.5,2C10.84,2 9.5,5.34 9.5,7C9.5,7.95 10,8.8 10,8.8C9.93,8.89 9.67,9.08 9.5,9.17C8.24,9.94 6,11.94 6,14.5C6,17.09 7.5,18 9,18.5C10.5,19 12,21 12,21H13C13,21 14.5,19 16,18.5C17.5,18 19,17.09 19,14.5C19,11.94 16.76,9.94 15.5,9.17C15.33,9.08 15.07,8.89 15,8.8C15,8.8 15.5,7.95 15.5,7C15.5,5.34 14.16,2 12.5,2Z' },
                { type: 'os', name: 'Android', color: '#3DDC84', 
                  svgPath: 'M7.2,16.8H8.8V19.2H7.2M16.8,16.8H18.4V19.2H16.8M3.6,7.2H21.6V15.6H3.6M16.8,3.6L18.4,6H16.8V3.6M7.2,3.6V6H5.6L7.2,3.6M7.2,22.8A1.8,1.8 0 0,1 5.4,21V19.2A1.8,1.8 0 0,1 7.2,17.4H8.8V15.6H7.2A3.6,3.6 0 0,0 3.6,19.2V21A3.6,3.6 0 0,0 7.2,24.6H8.8V22.8H7.2M18.4,22.8H16.8V24.6H18.4A3.6,3.6 0 0,0 22,21V19.2A3.6,3.6 0 0,0 18.4,15.6H16.8V17.4H18.4A1.8,1.8 0 0,1 20.2,19.2V21A1.8,1.8 0 0,1 18.4,22.8Z' },
                { type: 'os', name: 'iOS', color: '#007AFF', 
                  svgPath: 'M13,3.5C13.73,2.67 14.94,2.04 15.94,2C16.07,3.17 15.6,4.35 14.9,5.19C14.21,6.04 13.07,6.7 11.95,6.61C11.8,5.46 12.36,4.26 13,3.5M18.71,19.5C17.88,20.74 17,21.95 15.66,21.97C14.32,22 13.89,21.18 12.37,21.18C10.84,21.18 10.37,21.95 9.1,22C7.79,22.05 6.8,20.68 5.96,19.47C4.25,17 2.94,12.45 4.7,9.39C5.57,7.87 7.13,6.91 8.82,6.88C10.1,6.86 11.32,7.75 12.11,7.75C12.89,7.75 14.37,6.68 15.92,6.84C16.57,6.87 18.39,7.1 19.56,8.82C19.47,8.88 17.39,10.1 17.41,12.63C17.44,15.65 20.06,16.66 20.09,16.67C20.06,16.74 19.67,18.11 18.71,19.5Z' }
            ];
            
            // Icônes des appareils
            const deviceIcons = [
                { type: 'device', name: 'Smartphone', color: '#4285F4', 
                  svgPath: 'M17,19H7V5H17M17,1H7C5.89,1 5,1.89 5,3V21A2,2 0 0,0 7,23H17A2,2 0 0,0 19,21V3C19,1.89 18.1,1 17,1Z' },
                { type: 'device', name: 'Tablette', color: '#EA4335', 
                  svgPath: 'M19,18H5V6H19M21,4H3C1.89,4 1,4.89 1,6V18A2,2 0 0,0 3,20H21A2,2 0 0,0 23,18V6C23,4.89 22.1,4 21,4Z' },
                { type: 'device', name: 'Laptop', color: '#FBBC05', 
                  svgPath: 'M4,6H20V16H4M20,18A2,2 0 0,0 22,16V6C22,4.89 21.1,4 20,4H4C2.89,4 2,4.89 2,6V16A2,2 0 0,0 4,18H0V20H24V18H20Z' },
                { type: 'device', name: 'Desktop', color: '#34A853', 
                  svgPath: 'M21,16H3V4H21M21,2H3C1.89,2 1,2.89 1,4V16A2,2 0 0,0 3,18H10V20H8V22H16V20H14V18H21A2,2 0 0,0 23,16V4C23,2.89 22.1,2 21,2Z' },
                { type: 'device', name: 'TV', color: '#FF6D00', 
                  svgPath: 'M21,17H3V5H21M21,3H3A2,2 0 0,0 1,5V17A2,2 0 0,0 3,19H8V21H16V19H21A2,2 0 0,0 23,17V5A2,2 0 0,0 21,3Z' },
                { type: 'device', name: 'Smartwatch', color: '#9C27B0', 
                  svgPath: 'M6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12M8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8A4,4 0 0,0 8,12M12,2C17.52,2 22,6.48 22,12C22,17.52 17.52,22 12,22C6.48,22 2,17.52 2,12C2,6.48 6.48,2 12,2' }
            ];
            
            // Icônes des solutions de stockage
            const storageIcons = [
                { type: 'storage', name: 'Cloud', color: '#42A5F5', 
                  svgPath: 'M19.35,10.03C18.67,6.59 15.64,4 12,4C9.11,4 6.6,5.64 5.35,8.03C2.34,8.36 0,10.9 0,14A6,6 0 0,0 6,20H19A5,5 0 0,0 24,15C24,12.36 21.95,10.22 19.35,10.03Z' },
                { type: 'storage', name: 'Serveur', color: '#607D8B', 
                  svgPath: 'M4,1H20A1,1 0 0,1 21,2V6A1,1 0 0,1 20,7H4A1,1 0 0,1 3,6V2A1,1 0 0,1 4,1M4,9H20A1,1 0 0,1 21,10V14A1,1 0 0,1 20,15H4A1,1 0 0,1 3,14V10A1,1 0 0,1 4,9M4,17H20A1,1 0 0,1 21,18V22A1,1 0 0,1 20,23H4A1,1 0 0,1 3,22V18A1,1 0 0,1 4,17M9,5H10V3H9V5M9,13H10V11H9V13M9,21H10V19H9V21M5,3V5H7V3H5M5,11V13H7V11H5M5,19V21H7V19H5Z' },
                { type: 'storage', name: 'Base de données', color: '#1976D2', 
                  svgPath: 'M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M4,9V12C4,14.21 7.58,16 12,16C16.42,16 20,14.21 20,12V9C20,11.21 16.42,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C16.42,21 20,19.21 20,17V14C20,16.21 16.42,18 12,18C7.58,18 4,16.21 4,14Z' },
                { type: 'storage', name: 'DNS', color: '#78909C', 
                  svgPath: 'M7,9A2,2 0 0,1 5,7A2,2 0 0,1 7,5A2,2 0 0,1 9,7A2,2 0 0,1 7,9M20,3H4A1,1 0 0,0 3,4V10A1,1 0 0,0 4,11H20A1,1 0 0,0 21,10V4A1,1 0 0,0 20,3M7,19A2,2 0 0,1 5,17A2,2 0 0,1 7,15A2,2 0 0,1 9,17A2,2 0 0,1 7,19M20,13H4A1,1 0 0,0 3,14V20A1,1 0 0,0 4,21H20A1,1 0 0,0 21,20V14A1,1 0 0,0 20,13Z' },
                { type: 'storage', name: 'Disque dur', color: '#5D4037', 
                  svgPath: 'M6,2H18A2,2 0 0,1 20,4V20A2,2 0 0,1 18,22H6A2,2 0 0,1 4,20V4A2,2 0 0,1 6,2M12,4A6,6 0 0,0 6,10C6,13.31 8.69,16 12.1,16L11.22,13.77C10.95,13.29 11.11,12.68 11.59,12.4L12.45,11.9C12.93,11.63 13.54,11.79 13.82,12.27L15.74,14.69C17.12,13.59 18,11.9 18,10A6,6 0 0,0 12,4M12,9A1,1 0 0,1 13,10A1,1 0 0,1 12,11A1,1 0 0,1 11,10A1,1 0 0,1 12,9M7,18A1,1 0 0,0 6,19A1,1 0 0,0 7,20A1,1 0 0,0 8,19A1,1 0 0,0 7,18M12.09,13.27L14.58,19.58L17.17,18.08L12.95,12.77L12.09,13.27Z' }
            ];
            
            // Icônes de recherche, découverte, partage
            const actionIcons = [
                { type: 'action', name: 'Recherche', color: '#42A5F5', 
                  svgPath: 'M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z' },
                { type: 'action', name: 'Exploration', color: '#66BB6A', 
                  svgPath: 'M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12C4,14.09 4.8,16 6.11,17.41L9.88,9.88L17.41,6.11C16,4.8 14.09,4 12,4M12,20A8,8 0 0,0 20,12C20,9.91 19.2,8 17.89,6.59L14.12,14.12L6.59,17.89C8,19.2 9.91,20 12,20M12,12L11.23,11.23L9.7,14.3L12.77,12.77L12,12M12,17.5H13V19H12V17.5M15.88,15.89L16.59,15.18L17.65,16.24L16.94,16.95L15.88,15.89M17.5,12V11H19V12H17.5M12,6.5H11V5H12V6.5M8.12,8.11L7.41,8.82L6.35,7.76L7.06,7.05L8.12,8.11M6.5,12V13H5V12H6.5Z' },
                { type: 'action', name: 'Partage', color: '#FF7043', 
                  svgPath: 'M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L15.96,7.19C16.5,7.69 17.21,8 18,8A3,3 0 0,0 21,5A3,3 0 0,0 18,2A3,3 0 0,0 15,5C15,5.24 15.04,5.47 15.09,5.7L8.04,9.81C7.5,9.31 6.79,9 6,9A3,3 0 0,0 3,12A3,3 0 0,0 6,15C6.79,15 7.5,14.69 8.04,14.19L15.16,18.34C15.11,18.55 15.08,18.77 15.08,19C15.08,20.61 16.39,21.91 18,21.91C19.61,21.91 20.92,20.61 20.92,19A2.92,2.92 0 0,0 18,16.08Z' },
                { type: 'action', name: 'Lien', color: '#5C6BC0', 
                  svgPath: 'M3.9,12C3.9,10.29 5.29,8.9 7,8.9H11V7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H11V15.1H7C5.29,15.1 3.9,13.71 3.9,12M8,13H16V11H8V13M17,7H13V8.9H17C18.71,8.9 20.1,10.29 20.1,12C20.1,13.71 18.71,15.1 17,15.1H13V17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7Z' },
                { type: 'action', name: 'Téléchargement', color: '#26A69A', 
                  svgPath: 'M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z' }
            ];
            
            // Fusionner toutes les collections
            const allIcons = [
                ...folderIcons,
                ...osIcons,
                ...deviceIcons,
                ...storageIcons,
                ...actionIcons
            ];
            
            // ===========================================
            // GESTIONNAIRE DE SPRITES D'ICÔNES
            // ===========================================
            
            // Classe pour gérer le préchargement et le rendu optimisé des icônes
            class IconSpriteManager {
                constructor(iconsDefinitions) {
                    this.icons = iconsDefinitions;
                    this.spriteSheet = document.createElement('canvas');
                    this.spriteCtx = this.spriteSheet.getContext('2d');
                    this.iconSize = 24; // Taille standard des icônes
                    this.padding = 1;  // Espacement entre les icônes dans la spritesheet
                    this.spritesPerRow = 10;
                    this.spritePositions = new Map(); // Stocke les positions des icônes dans la spritesheet
                    this.faviconCache = new Map(); // Cache pour les favicons de sites web
                    this.ready = false;
                }
                
                // Initialiser la spritesheet
                async initialize() {
                    const totalIcons = this.icons.length;
                    const rows = Math.ceil(totalIcons / this.spritesPerRow);
                    
                    this.spriteSheet.width = this.spritesPerRow * (this.iconSize + this.padding * 2);
                    this.spriteSheet.height = rows * (this.iconSize + this.padding * 2);
                    
                    // Dessiner les icônes SVG sur la spritesheet
                    for (let i = 0; i < this.icons.length; i++) {
                        const icon = this.icons[i];
                        const row = Math.floor(i / this.spritesPerRow);
                        const col = i % this.spritesPerRow;
                        
                        const x = col * (this.iconSize + this.padding * 2) + this.padding;
                        const y = row * (this.iconSize + this.padding * 2) + this.padding;
                        
                        // Enregistrer la position dans la map
                        this.spritePositions.set(icon, { x, y });
                        
                        // Dessiner l'icône sur la spritesheet
                        this.drawSVGIcon(icon, x, y);
                    }
                    
                    // Précharger les favicons des sites web
                    await this.preloadFavicons(websites);
                    
                    this.ready = true;
                    return this;
                }
                
                // Dessiner une icône SVG sur la spritesheet
                drawSVGIcon(icon, x, y) {
                    // Configurer le contexte pour dessiner l'icône
                    this.spriteCtx.save();
                    this.spriteCtx.fillStyle = icon.color || '#FFFFFF';
                    
                    // Dessiner le cercle de fond
                    this.spriteCtx.beginPath();
                    this.spriteCtx.arc(x + this.iconSize / 2, y + this.iconSize / 2, this.iconSize / 2, 0, Math.PI * 2);
                    this.spriteCtx.fillStyle = 'rgba(42, 42, 58, 0.8)'; // Couleur de fond similaire à var(--card-dark)
                    this.spriteCtx.fill();
                    
                    // Dessiner le path SVG
                    this.spriteCtx.translate(x, y);
                    this.spriteCtx.fillStyle = icon.color || '#FFFFFF';
                    
                    const path = new Path2D(icon.svgPath);
                    // Mettre à l'échelle le SVG pour l'adapter à la taille de l'icône
                    this.spriteCtx.scale(this.iconSize / 24, this.iconSize / 24);
                    this.spriteCtx.fill(path);
                    
                    this.spriteCtx.restore();
                }
                
                // Précharger les favicons
                async preloadFavicons(sites) {
                    const promises = sites.map(site => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = 'Anonymous';
                            img.onload = () => {
                                // Créer un petit canvas pour dessiner le favicon
                                const canvas = document.createElement('canvas');
                                canvas.width = this.iconSize;
                                canvas.height = this.iconSize;
                                const ctx = canvas.getContext('2d');
                                
                                // Dessiner le cercle de fond
                                ctx.beginPath();
                                ctx.arc(this.iconSize / 2, this.iconSize / 2, this.iconSize / 2, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(42, 42, 58, 0.8)';
                                ctx.fill();
                                
                                // Dessiner le favicon centré
                                const iconSize = this.iconSize * 0.75;
                                ctx.drawImage(img, 
                                    (this.iconSize - iconSize) / 2, 
                                    (this.iconSize - iconSize) / 2, 
                                    iconSize, iconSize);
                                
                                this.faviconCache.set(site, canvas);
                                resolve();
                            };
                            img.onerror = () => {
                                // En cas d'erreur, utiliser une icône de globe par défaut
                                const defaultIcon = actionIcons.find(icon => icon.name === 'Exploration');
                                const canvas = document.createElement('canvas');
                                canvas.width = this.iconSize;
                                canvas.height = this.iconSize;
                                const ctx = canvas.getContext('2d');
                                
                                // Dessiner le cercle de fond
                                ctx.beginPath();
                                ctx.arc(this.iconSize / 2, this.iconSize / 2, this.iconSize / 2, 0, Math.PI * 2);
                                ctx.fillStyle = 'rgba(42, 42, 58, 0.8)';
                                ctx.fill();
                                
                                // Dessiner une icône générique
                                ctx.fillStyle = '#4285F4';
                                const path = new Path2D(defaultIcon.svgPath);
                                ctx.scale(this.iconSize / 24, this.iconSize / 24);
                                ctx.fill(path);
                                
                                this.faviconCache.set(site, canvas);
                                resolve();
                            };
                            img.src = `https://www.google.com/s2/favicons?domain=${site}&sz=64`;
                        });
                    });
                    
                    await Promise.all(promises);
                }
                
                // Dessiner une icône à partir du sprite
                drawIcon(ctx, iconOrSite, x, y, size = this.iconSize, type = 'svg') {
                    if (!this.ready) return;
                    
                    ctx.save();
                    
                    if (type === 'favicon' && this.faviconCache.has(iconOrSite)) {
                        // Dessiner un favicon depuis le cache
                        const faviconCanvas = this.faviconCache.get(iconOrSite);
                        ctx.drawImage(faviconCanvas, x - size/2, y - size/2, size, size);
                    } else if (type === 'svg' && this.spritePositions.has(iconOrSite)) {
                        // Dessiner une icône SVG depuis la spritesheet
                        const pos = this.spritePositions.get(iconOrSite);
                        ctx.drawImage(
                            this.spriteSheet, 
                            pos.x, pos.y, 
                            this.iconSize, this.iconSize,
                            x - size/2, y - size/2, 
                            size, size
                        );
                    } else {
                        // Fallback: dessiner un cercle coloré
                        ctx.beginPath();
                        ctx.arc(x, y, size/2, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(42, 42, 58, 0.8)';
                        ctx.fill();
                        
                        // Ajouter une lettre ou un symbole
                        ctx.fillStyle = '#FFFFFF';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = `${size/2}px sans-serif`;
                        ctx.fillText('?', x, y);
                    }
                    
                    ctx.restore();
                }
            }
            
            // ===========================================
            // GESTIONNAIRE D'ICÔNES ET TOILE D'ARAIGNÉE
            // ===========================================
            
            class SpiderWebManager {
                constructor(iconManager) {
                    this.iconManager = iconManager;
                    this.webLines = [];
                    this.mainIcons = [];
                    this.secondaryIcons = [];
                    this.highlightedLine = null;
                    this.webCircles = [];
                    this.animatedLines = new Set();
                    
                    // Propriétés pour animation fluide
                    this.time = 0;
                    this.targetCameraOpacity = 0;
                    this.currentCameraOpacity = 0;
                    
                    // Configuration
                    this.numMainIcons = websites.length;
                    this.numSecondaryIcons = 5000; // Plusieurs milliers d'icônes
                    this.maxWebLines = 300;
                    this.numWebCircles = 8;
                }
                
                initialize() {
                    // Créer les cercles concentriques
                    this.createWebCircles();
                    
                    // Créer les icônes principales (sites web)
                    this.createMainIcons();
                    
                    // Créer les icônes secondaires
                    this.createSecondaryIcons();
                    
                    // Créer les liens entre certaines icônes
                    this.createWebConnections();
                }
                
                // Créer les cercles concentriques
                createWebCircles() {
                    const maxRadius = Math.min(window.innerWidth, window.innerHeight) * 0.8;
                    
                    for (let i = 1; i <= this.numWebCircles; i++) {
                        this.webCircles.push({
                            radius: maxRadius * (i / this.numWebCircles),
                            opacity: 0.05
                        });
                    }
                }
                
                // Créer les icônes principales
                createMainIcons() {
                    const distance = Math.min(window.innerWidth, window.innerHeight) * 0.4;
                    
                    for (let i = 0; i < this.numMainIcons; i++) {
                        const angle = (i / this.numMainIcons) * 2 * Math.PI;
                        const x = Math.cos(angle) * distance + centerX;
                        const y = Math.sin(angle) * distance + centerY;
                        
                        this.mainIcons.push({
                            site: websites[i],
                            x: x,
                            y: y,
                            size: 32,
                            angle: angle,
                            opacity: 0,
                            scale: 0,
                            targetOpacity: 1,
                            targetScale: 1,
                            animationDelay: 500 + i * 50
                        });
                        
                        // Ajouter une ligne de toile pour cette icône
                        this.webLines.push({
                            startX: centerX,
                            startY: centerY,
                            endX: x,
                            endY: y,
                            angle: angle,
                            length: distance,
                            opacity: 0,
                            targetOpacity: 1,
                            width: 1,
                            highlighted: false,
                            animationDelay: 500 + i * 50
                        });
                    }
                }
                
                // Créer les icônes secondaires
                createSecondaryIcons() {
                    // Distribution des icônes par profondeur
                    const depthDistribution = [
                        { depth: 1, percentage: 0.1, sizeFactor: 0.8, radius: 0.8 },
                        { depth: 2, percentage: 0.3, sizeFactor: 0.6, radius: 0.6 },
                        { depth: 3, percentage: 0.6, sizeFactor: 0.4, radius: 0.4 }
                    ];
                    
                    for (let i = 0; i < this.numSecondaryIcons; i++) {
                        // Déterminer la profondeur
                        const randomValue = Math.random();
                        let depth, sizeFactor, radiusFactor;
                        
                        if (randomValue < depthDistribution[0].percentage) {
                            depth = 1;
                            sizeFactor = depthDistribution[0].sizeFactor;
                            radiusFactor = depthDistribution[0].radius;
                        } else if (randomValue < depthDistribution[0].percentage + depthDistribution[1].percentage) {
                            depth = 2;
                            sizeFactor = depthDistribution[1].sizeFactor;
                            radiusFactor = depthDistribution[1].radius;
                        } else {
                            depth = 3;
                            sizeFactor = depthDistribution[2].sizeFactor;
                            radiusFactor = depthDistribution[2].radius;
                        }
                        
                        // Générer position sur un cercle concentrique avec variation
                        const baseRadius = Math.min(window.innerWidth, window.innerHeight) * 0.6;
                        const radiusVariation = 0.1; // Variation pour ne pas avoir des cercles parfaits
                        const radius = baseRadius * radiusFactor * (1 + (Math.random() * radiusVariation * 2 - radiusVariation));
                        
                        // Angle aléatoire
                        const angle = Math.random() * 2 * Math.PI;
                        
                        // Position
                        const x = Math.cos(angle) * radius + centerX;
                        const y = Math.sin(angle) * radius + centerY;
                        
                        // Taille en fonction de la profondeur
                        const baseSize = 20;
                        const size = baseSize * sizeFactor;
                        
                        // Choisir une icône aléatoire
                        const randomIcon = allIcons[Math.floor(Math.random() * allIcons.length)];
                        
                        this.secondaryIcons.push({
                            icon: randomIcon,
                            x: x,
                            y: y,
                            size: size,
                            depth: depth,
                            angle: angle,
                            radius: radius,
                            opacity: 0,
                            scale: 0,
                            targetOpacity: depth === 3 ? 0.7 : 1,
                            targetScale: 1,
                            animationDelay: 2000 + (i % 100) * 20
                        });
                        
                        // Ajouter occasionnellement des lignes de toile pour les icônes de profondeur 1
                        if (depth === 1 && i % 5 === 0 && this.webLines.length < this.maxWebLines) {
                            const webLine = {
                                startX: centerX,
                                startY: centerY,
                                endX: x,
                                endY: y,
                                angle: angle,
                                length: radius,
                                opacity: 0,
                                targetOpacity: 0.1,
                                width: 1,
                                highlighted: false,
                                pulsate: Math.random() < 0.3,
                                animationDelay: 2500 + (i % 50) * 30
                            };
                            
                            this.webLines.push(webLine);
                        }
                    }
                }
                
                // Créer des connections entre certaines icônes proches
                createWebConnections() {
                    // Utiliser seulement les icônes de profondeur 1 pour les connexions
                    const depth1Icons = this.secondaryIcons.filter(icon => icon.depth === 1);
                    const maxConnections = Math.min(500, depth1Icons.length * 2);
                    
                    for (let i = 0; i < maxConnections; i++) {
                        if (this.webLines.length >= this.maxWebLines) break;
                        
                        const icon1 = depth1Icons[Math.floor(Math.random() * depth1Icons.length)];
                        const icon2 = depth1Icons[Math.floor(Math.random() * depth1Icons.length)];
                        
                        if (icon1 === icon2) continue;
                        
                        // Calculer la distance
                        const dx = icon2.x - icon1.x;
                        const dy = icon2.y - icon1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Ne connecter que les icônes relativement proches
                        if (distance < 200) {
                            const angle = Math.atan2(dy, dx);
                            
                            this.webLines.push({
                                startX: icon1.x,
                                startY: icon1.y,
                                endX: icon2.x,
                                endY: icon2.y,
                                angle: angle,
                                length: distance,
                                opacity: 0,
                                targetOpacity: 0.05,
                                width: 1,
                                highlighted: false,
                                isConnection: true,
                                animationDelay: 4000 + i * 10
                            });
                        }
                    }
                }
                
                // Mettre à jour l'animation
                update(deltaTime) {
                    this.time += deltaTime;
                    
                    // Mettre à jour les opacités et échelles des icônes
                    const now = Date.now();
                    
                    // Mettre à jour les icônes principales
                    this.mainIcons.forEach(icon => {
                        if (now > icon.animationDelay) {
                            icon.opacity += (icon.targetOpacity - icon.opacity) * 0.05;
                            icon.scale += (icon.targetScale - icon.scale) * 0.05;
                        }
                    });
                    
                    // Mettre à jour les icônes secondaires
                    this.secondaryIcons.forEach(icon => {
                        if (now > icon.animationDelay) {
                            icon.opacity += (icon.targetOpacity - icon.opacity) * 0.05;
                            icon.scale += (icon.targetScale - icon.scale) * 0.05;
                        }
                    });
                    
                    // Mettre à jour les lignes
                    this.webLines.forEach(line => {
                        if (now > line.animationDelay) {
                            line.opacity += (line.targetOpacity - line.opacity) * 0.05;
                            
                            // Animation de pulsation pour certaines lignes
                            if (line.pulsate) {
                                const pulseFactor = Math.sin(this.time * 0.001) * 0.1 + 0.9;
                                line.opacity = line.targetOpacity * pulseFactor;
                            }
                        }
                    });
                    
                    // Animer aléatoirement certaines lignes
                    if (Math.random() < 0.01 && this.animatedLines.size < 10) {
                        const eligibleLines = this.webLines.filter(
                            line => !line.highlighted && !this.animatedLines.has(line)
                        );
                        
                        if (eligibleLines.length > 0) {
                            const randomLine = eligibleLines[Math.floor(Math.random() * eligibleLines.length)];
                            randomLine.highlighted = true;
                            randomLine.originalOpacity = randomLine.opacity;
                            randomLine.targetOpacity = 0.3;
                            randomLine.width = 1.5;
                            this.animatedLines.add(randomLine);
                            
                            // Réinitialiser après animation
                            setTimeout(() => {
                                randomLine.highlighted = false;
                                randomLine.targetOpacity = randomLine.originalOpacity || 0.1;
                                randomLine.width = 1;
                                this.animatedLines.delete(randomLine);
                            }, 500 + Math.random() * 1000);
                        }
                    }
                    
                    // Animer l'effet de caméra web
                    this.currentCameraOpacity += (this.targetCameraOpacity - this.currentCameraOpacity) * 0.1;
                }
                
                // Dessiner sur le canvas
                draw() {
                    // Effacer le canvas
                    iconCtx.clearRect(0, 0, iconsCanvas.width, iconsCanvas.height);
                    
                    // Dessiner les cercles concentriques
                    this.webCircles.forEach(circle => {
                        iconCtx.beginPath();
                        iconCtx.arc(centerX, centerY, circle.radius, 0, Math.PI * 2);
                        iconCtx.strokeStyle = `rgba(255, 255, 255, ${circle.opacity})`;
                        iconCtx.lineWidth = 1;
                        iconCtx.stroke();
                    });
                    
                    // Dessiner les lignes de toile
                    this.webLines.forEach(line => {
                        if (line.opacity > 0.01) {
                            iconCtx.beginPath();
                            iconCtx.moveTo(line.startX, line.startY);
                            iconCtx.lineTo(line.endX, line.endY);
                            
                            // Déterminer le style selon que la ligne est mise en évidence ou non
                            if (line.highlighted) {
                                iconCtx.strokeStyle = `rgba(255, 255, 255, ${line.opacity})`;
                                iconCtx.shadowBlur = 5;
                                iconCtx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                            } else {
                                iconCtx.strokeStyle = `rgba(255, 255, 255, ${line.opacity})`;
                                iconCtx.shadowBlur = 0;
                            }
                            
                            iconCtx.lineWidth = line.width || 1;
                            iconCtx.stroke();
                        }
                    });
                    
                    // Dessiner les icônes en ordre inverse de profondeur (arrière-plan d'abord)
                    // Icônes secondaires de profondeur 3
                    this.secondaryIcons
                        .filter(icon => icon.depth === 3 && icon.opacity > 0.01)
                        .forEach(icon => {
                            if (icon.scale > 0.01) {
                                iconCtx.globalAlpha = icon.opacity;
                                this.iconManager.drawIcon(
                                    iconCtx, 
                                    icon.icon, 
                                    icon.x, 
                                    icon.y, 
                                    icon.size * icon.scale
                                );
                            }
                        });
                    
                    // Icônes secondaires de profondeur 2
                    this.secondaryIcons
                        .filter(icon => icon.depth === 2 && icon.opacity > 0.01)
                        .forEach(icon => {
                            if (icon.scale > 0.01) {
                                iconCtx.globalAlpha = icon.opacity;
                                this.iconManager.drawIcon(
                                    iconCtx, 
                                    icon.icon, 
                                    icon.x, 
                                    icon.y, 
                                    icon.size * icon.scale
                                );
                            }
                        });
                    
                    // Icônes secondaires de profondeur 1
                    this.secondaryIcons
                        .filter(icon => icon.depth === 1 && icon.opacity > 0.01)
                        .forEach(icon => {
                            if (icon.scale > 0.01) {
                                iconCtx.globalAlpha = icon.opacity;
                                this.iconManager.drawIcon(
                                    iconCtx, 
                                    icon.icon, 
                                    icon.x, 
                                    icon.y, 
                                    icon.size * icon.scale
                                );
                            }
                        });
                    
                    // Icônes principales (sites web)
                    this.mainIcons.forEach(icon => {
                        if (icon.opacity > 0.01 && icon.scale > 0.01) {
                            iconCtx.globalAlpha = icon.opacity;
                            this.iconManager.drawIcon(
                                iconCtx, 
                                icon.site, 
                                icon.x, 
                                icon.y, 
                                icon.size * icon.scale,
                                'favicon'
                            );
                        }
                    });
                    
                    // Réinitialiser l'opacité globale
                    iconCtx.globalAlpha = 1;
                    
                    // Dessiner l'effet de caméra web si actif
                    if (this.currentCameraOpacity > 0.01) {
                        iconCtx.fillStyle = `rgba(255, 255, 255, ${this.currentCameraOpacity * 0.1})`;
                        
                        // Créer un motif de grille
                        for (let x = 0; x < iconsCanvas.width; x += 30) {
                            for (let y = 0; y < iconsCanvas.height; y += 30) {
                                iconCtx.beginPath();
                                iconCtx.arc(x, y, 1, 0, Math.PI * 2);
                                iconCtx.fill();
                            }
                        }
                    }
                }
                
                // Mettre en évidence une ligne proche d'un angle
                highlightNearestWebLine(shotAngle) {
                    // Normaliser l'angle à [-π, π]
                    while (shotAngle > Math.PI) shotAngle -= 2 * Math.PI;
                    while (shotAngle < -Math.PI) shotAngle += 2 * Math.PI;
                    
                    let closestLine = null;
                    let minAngleDiff = Math.PI;
                    
                    this.webLines.forEach(line => {
                        let lineAngle = line.angle;
                        
                        // Normaliser l'angle de la ligne
                        while (lineAngle > Math.PI) lineAngle -= 2 * Math.PI;
                        while (lineAngle < -Math.PI) lineAngle += 2 * Math.PI;
                        
                        const angleDiff = Math.abs(shotAngle - lineAngle);
                        const normalizedDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        if (normalizedDiff < minAngleDiff) {
                            minAngleDiff = normalizedDiff;
                            closestLine = line;
                        }
                    });
                    
                    // Réinitialiser les lignes précédemment mises en évidence
                    this.resetWebLineHighlights();
                    
                    if (closestLine && minAngleDiff < Math.PI / 8) {
                        closestLine.highlighted = true;
                        closestLine.originalOpacity = closestLine.opacity;
                        closestLine.targetOpacity = 0.3;
                        closestLine.width = 1.5;
                        this.highlightedLine = closestLine;
                    }
                }
                
                // Réinitialiser la mise en évidence des lignes
                resetWebLineHighlights() {
                    if (this.highlightedLine) {
                        this.highlightedLine.highlighted = false;
                        this.highlightedLine.targetOpacity = this.highlightedLine.originalOpacity || 0.1;
                        this.highlightedLine.width = 1;
                        this.highlightedLine = null;
                    }
                }
                
                // Activer l'effet de caméra web
                activateCameraWeb() {
                    this.targetCameraOpacity = 1;
                    
                    setTimeout(() => {
                        this.targetCameraOpacity = 0;
                    }, 1000);
                }
                
                // Redimensionner en fonction de la taille de la fenêtre
                resize() {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Mettre à jour les cercles concentriques
                    const maxRadius = Math.min(window.innerWidth, window.innerHeight) * 0.8;
                    this.webCircles.forEach((circle, index) => {
                        circle.radius = maxRadius * ((index + 1) / this.numWebCircles);
                    });
                    
                    // Mettre à jour les icônes principales
                    const mainDistance = Math.min(window.innerWidth, window.innerHeight) * 0.4;
                    this.mainIcons.forEach((icon, index) => {
                        const angle = (index / this.numMainIcons) * 2 * Math.PI;
                        icon.x = Math.cos(angle) * mainDistance + centerX;
                        icon.y = Math.sin(angle) * mainDistance + centerY;
                        icon.angle = angle;
                    });
                    
                    // Mettre à jour les lignes principales
                    for (let i = 0; i < this.numMainIcons; i++) {
                        const icon = this.mainIcons[i];
                        const line = this.webLines[i];
                        
                        line.startX = centerX;
                        line.startY = centerY;
                        line.endX = icon.x;
                        line.endY = icon.y;
                        line.angle = icon.angle;
                        line.length = mainDistance;
                    }
                    
                    // Mettre à jour les icônes secondaires
                    this.secondaryIcons.forEach(icon => {
                        const radiusFactor = icon.depth === 1 ? 0.8 : (icon.depth === 2 ? 0.6 : 0.4);
                        const baseRadius = Math.min(window.innerWidth, window.innerHeight) * 0.6;
                        const radius = baseRadius * radiusFactor * (1 + Math.random() * 0.1 - 0.05);
                        
                        icon.x = Math.cos(icon.angle) * radius + centerX;
                        icon.y = Math.sin(icon.angle) * radius + centerY;
                        icon.radius = radius;
                    });
                    
                    // Mettre à jour les lignes secondaires
                    this.webLines.slice(this.numMainIcons).forEach(line => {
                        if (!line.isConnection) {
                            line.startX = centerX;
                            line.startY = centerY;
                            
                            // Trouver l'icône associée à cette ligne
                            const matchingIcon = this.secondaryIcons.find(
                                icon => Math.abs(icon.angle - line.angle) < 0.01 && 
                                       Math.abs(icon.radius - line.length) < 10
                            );
                            
                            if (matchingIcon) {
                                line.endX = matchingIcon.x;
                                line.endY = matchingIcon.y;
                                line.length = matchingIcon.radius;
                            }
                        }
                    });
                }
            }
            
            // ===========================================
            // GESTIONNAIRE D'ANIMATIONS ET DE RENDU
            // ===========================================
            
            class AnimationManager {
                constructor() {
                    this.lastFrameTime = 0;
                    this.frameCount = 0;
                    this.fps = 0;
                    this.fpsUpdateInterval = 500; // ms
                    this.lastFpsUpdate = 0;
                    this.running = false;
                    this.callbacks = {
                        update: [],
                        draw: []
                    };
                }
                
                start() {
                    if (this.running) return;
                    
                    this.running = true;
                    this.lastFrameTime = performance.now();
                    this.lastFpsUpdate = this.lastFrameTime;
                    this.frameCount = 0;
                    
                    this.animationLoop();
                }
                
                stop() {
                    this.running = false;
                }
                
                addUpdateCallback(callback) {
                    this.callbacks.update.push(callback);
                    return this;
                }
                
                addDrawCallback(callback) {
                    this.callbacks.draw.push(callback);
                    return this;
                }
                
                animationLoop(currentTime) {
                    if (!this.running) return;
                    
                    // Calculer le delta time
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.lastFrameTime = currentTime;
                    
                    // Mettre à jour le FPS
                    this.frameCount++;
                    if (currentTime - this.lastFpsUpdate > this.fpsUpdateInterval) {
                        this.fps = 1000 * this.frameCount / (currentTime - this.lastFpsUpdate);
                        this.lastFpsUpdate = currentTime;
                        this.frameCount = 0;
                    }
                    
                    // Exécuter les callbacks d'update
                    for (const callback of this.callbacks.update) {
                        callback(deltaTime / 1000);
                    }
                    
                    // Exécuter les callbacks de dessin
                    for (const callback of this.callbacks.draw) {
                        callback();
                    }
                    
                    // Continuer la boucle
                    requestAnimationFrame(this.animationLoop.bind(this));
                }
            }
            
            // ===========================================
            // GESTIONNAIRE DE FOND ANIMÉ
            // ===========================================
            
            class BackgroundManager {
                constructor() {
                    this.time = 0;
                    this.stars = [];
                    this.numStars = 100;
                    
                    // Générer les étoiles
                    for (let i = 0; i < this.numStars; i++) {
                        this.stars.push({
                            x: Math.random() * backgroundCanvas.width,
                            y: Math.random() * backgroundCanvas.height,
                            size: Math.random() * 2 + 1,
                            blinkSpeed: Math.random() * 5 + 1,
                            blinkOffset: Math.random() * Math.PI * 2
                        });
                    }
                }
                
                update(deltaTime) {
                    this.time += deltaTime;
                }
                
                draw() {
                    // Fond dégradé sombre
                    const gradient = bgCtx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, Math.max(centerX, centerY)
                    );
                    gradient.addColorStop(0, '#1e1e2e');
                    gradient.addColorStop(1, '#12121e');
                    
                    bgCtx.fillStyle = gradient;
                    bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                    
                    // Dessiner les étoiles
                    for (const star of this.stars) {
                        const brightness = (Math.sin(this.time * star.blinkSpeed + star.blinkOffset) + 1) * 0.5;
                        bgCtx.fillStyle = `rgba(255, 255, 255, ${0.3 + brightness * 0.7})`;
                        bgCtx.beginPath();
                        bgCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        bgCtx.fill();
                    }
                }
                
                resize() {
                    // Repositionner les étoiles
                    for (let i = 0; i < this.numStars; i++) {
                        this.stars[i].x = Math.random() * backgroundCanvas.width;
                        this.stars[i].y = Math.random() * backgroundCanvas.height;
                    }
                }
            }
            
// ===========================================
// FONCTIONS POUR L'ARAIGNÉE ET LES ANIMATIONS
// ===========================================

// Fonction pour créer un tir de toile
function createWebShot(source, target, callback) {
    const sourceRect = source.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();
    
    const startX = sourceRect.left + sourceRect.width / 2;
    const startY = sourceRect.top + sourceRect.height / 2;
    const endX = targetRect.left + targetRect.width / 2;
    const endY = targetRect.top + targetRect.height / 2;
    
    const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const angle = Math.atan2(endY - startY, endX - startX);
    
    const webShot = document.createElement('div');
    webShot.className = 'web-shot';
    webShot.style.left = `${startX}px`;
    webShot.style.top = `${startY}px`;
    webShot.style.width = '0';
    webShot.style.height = '2px';
    webShot.style.transform = `rotate(${angle}rad)`;
    document.body.appendChild(webShot);
    
    // Animer le tir de toile
    setTimeout(() => {
        webShot.style.transition = 'width 0.3s ease-out, opacity 0.3s ease-out';
        webShot.style.width = `${distance}px`;
        webShot.style.opacity = '1';
        
        // Retirer avec la cible
        setTimeout(() => {
            webShot.style.transition = 'width 0.3s ease-in';
            webShot.style.width = '0';
            
            if (callback) {
                callback();
            }
            
            // Supprimer l'élément de toile
            setTimeout(() => {
                webShot.remove();
            }, 300);
        }, 300);
    }, 10);
}

// Fonction pour suivre les pupilles
function trackPupils(e) {
    if (document.activeElement === password && !password.type.includes('text')) {
        // Yeux fermés quand on tape dans le champ de mot de passe
        leftPupil.parentElement.style.height = '1px';
        rightPupil.parentElement.style.height = '1px';
        return;
    } else {
        leftPupil.parentElement.style.height = '';
        rightPupil.parentElement.style.height = '';
    }
    
    const eyeRect = leftPupil.parentElement.getBoundingClientRect();
    const eyeCenterX = eyeRect.left + eyeRect.width / 2;
    const eyeCenterY = eyeRect.top + eyeRect.height / 2;
    
    const maxDistance = eyeRect.width / 4;
    const angle = Math.atan2(e.clientY - eyeCenterY, e.clientX - eyeCenterX);
    const distance = Math.min(maxDistance, Math.sqrt(Math.pow(e.clientX - eyeCenterX, 2) + Math.pow(e.clientY - eyeCenterY, 2)) / 10);
    
    const x = Math.cos(angle) * distance;
    const y = Math.sin(angle) * distance;
    
    leftPupil.style.transform = `translate(${x}px, ${y}px)`;
    rightPupil.style.transform = `translate(${x}px, ${y}px)`;
}

// Fonction pour configurer les animations inactives
function setupIdleAnimations() {
    const animations = [
        // Clignotement
        () => {
            leftPupil.parentElement.style.height = '1px';
            rightPupil.parentElement.style.height = '1px';
            setTimeout(() => {
                leftPupil.parentElement.style.height = '';
                rightPupil.parentElement.style.height = '';
            }, 150);
        },
        // Regarder à gauche
        () => {
            leftPupil.style.transform = 'translate(-3px, 0)';
            rightPupil.style.transform = 'translate(-3px, 0)';
            setTimeout(() => {
                leftPupil.style.transform = '';
                rightPupil.style.transform = '';
            }, 1500);
        },
        // Regarder à droite
        () => {
            leftPupil.style.transform = 'translate(3px, 0)';
            rightPupil.style.transform = 'translate(3px, 0)';
            setTimeout(() => {
                leftPupil.style.transform = '';
                rightPupil.style.transform = '';
            }, 1500);
        },
        // Tirer une toile vers la caméra
        () => {
            cameraWeb.style.opacity = '1';
            setTimeout(() => {
                cameraWeb.style.opacity = '0';
            }, 1000);
        }
    ];
    
    // Démarrer une animation aléatoire toutes les 5-10 secondes si pas d'activité utilisateur
    let lastActivity = Date.now();
    let animationTimer;
    
    function startRandomAnimation() {
        if (Date.now() - lastActivity > 5000) {
            const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
            randomAnimation();
        }
        
        animationTimer = setTimeout(() => {
            startRandomAnimation();
        }, 5000 + Math.random() * 5000);
    }
    
    // Réinitialiser le timer d'activité sur les interactions utilisateur
    document.addEventListener('mousemove', () => {
        lastActivity = Date.now();
    });
    
    document.addEventListener('keydown', () => {
        lastActivity = Date.now();
    });
    
    document.addEventListener('click', () => {
        lastActivity = Date.now();
    });
    
    // Démarrer les animations inactives
    startRandomAnimation();
}

            
            // ===========================================
            // GESTIONNAIRE DU FORMULAIRE DE CONNEXION
            // ===========================================
            
            class LoginFormManager {
                constructor(spiderManager) {
                    this.loginContainer = loginContainer;
                    this.titleSpans = titleSpans;
                    this.usernameGroup = usernameGroup;
                    this.passwordGroup = passwordGroup;
                    this.loginButton = loginButton;
                    this.passwordToggle = passwordToggle;
                    this.password = password;
                    this.username = username;
                    this.spiderManager = spiderManager;
                    
                    // Initialiser l'état du formulaire
                    this.loginContainer.style.opacity = '0';
                    
                    // Configurer les gestionnaires d'événements
                    this.setupEventHandlers();
                }
                
                // Configurer les gestionnaires d'événements
                setupEventHandlers() {
                    // Suivi de la saisie dans le champ nom d'utilisateur
                    this.username.addEventListener('input', () => {
                        const rect = this.username.getBoundingClientRect();
                        const x = rect.left + this.username.value.length * 8;
                        const y = rect.top + rect.height / 2;
                        
                        this.spiderManager.trackEyes(x, y);
                    });
                    
                    // Basculement de visibilité du mot de passe
                    this.passwordToggle.addEventListener('click', () => {
                        if (this.password.type === 'password') {
                            this.password.type = 'text';
                            this.spiderManager.leftPupil.parentElement.style.height = '';
                            this.spiderManager.rightPupil.parentElement.style.height = '';
                        } else {
                            this.password.type = 'password';
                            if (document.activeElement === this.password) {
                                this.spiderManager.leftPupil.parentElement.style.height = '1px';
                                this.spiderManager.rightPupil.parentElement.style.height = '1px';
                            }
                        }
                    });
                    
                    // Focus et blur pour le champ mot de passe
                    this.password.addEventListener('focus', () => {
                        if (this.password.type === 'password') {
                            this.spiderManager.leftPupil.parentElement.style.height = '1px';
                            this.spiderManager.rightPupil.parentElement.style.height = '1px';
                        }
                    });
                    
                    this.password.addEventListener('blur', () => {
                        this.spiderManager.leftPupil.parentElement.style.height = '';
                        this.spiderManager.rightPupil.parentElement.style.height = '';
                    });
                }
                
                // Animer l'apparition du formulaire
                animateForm() {
                    // Créer une fonction pour l'animation de tir de toile
                    const createWebShot = (target, callback) => {
                        // Obtenir les positions de l'araignée et de la cible
                        const spiderRect = this.spiderManager.spiderElement.getBoundingClientRect();
                        const targetRect = target.getBoundingClientRect();
                        
                        const startX = spiderRect.left + spiderRect.width / 2;
                        const startY = spiderRect.top + spiderRect.height / 2;
                        const endX = targetRect.left + targetRect.width / 2;
                        const endY = targetRect.top + targetRect.height / 2;
                        
                        // Calculer la distance et l'angle
                        const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                        const angle = Math.atan2(endY - startY, endX - startX);
                        
                        // Créer l'élément de toile
                        const webShot = document.createElement('div');
                        webShot.className = 'web-shot';
                        webShot.style.left = `${startX}px`;
                        webShot.style.top = `${startY}px`;
                        webShot.style.width = '0';
                        webShot.style.height = '2px';
                        webShot.style.transform = `rotate(${angle}rad)`;
                        document.body.appendChild(webShot);
                        
                        // Mettre en évidence la ligne de toile la plus proche
                        this.spiderManager.spiderWebManager.highlightNearestWebLine(angle);
                        
                        // Animer les pattes de l'araignée
                        this.spiderManager.animateLegs(angle);
                        
                        // Animer le tir de toile
                        setTimeout(() => {
                            webShot.style.transition = 'width 0.3s ease-out, opacity 0.3s ease-out';
                            webShot.style.width = `${distance}px`;
                            webShot.style.opacity = '1';
                            
                            // Retirer avec la cible
                            setTimeout(() => {
                                webShot.style.transition = 'width 0.3s ease-in';
                                webShot.style.width = '0';
                                
                                if (callback) {
                                    callback();
                                }
                                
                                // Supprimer l'élément de toile
                                setTimeout(() => {
                                    webShot.remove();
                                    this.spiderManager.spiderWebManager.resetWebLineHighlights();
                                    this.spiderManager.resetLegs();
                                }, 300);
                            }, 300);
                        }, 10);
                    };
                    
                    // Séquence d'animation
                    // 1. Tirer sur le conteneur de connexion
                    createWebShot(this.loginContainer, () => {
                        this.loginContainer.style.transition = 'opacity 1s ease-in-out';
                        this.loginContainer.style.opacity = '1';
                        
                        // 2. Animer les lettres du titre
                        setTimeout(() => {
                            this.titleSpans.forEach((span, index) => {
                                setTimeout(() => {
                                    createWebShot(span, () => {
                                        span.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                        span.style.opacity = '1';
                                        span.style.transform = 'translateY(0)';
                                    });
                                }, index * 300);
                            });
                            
                            // 3. Animer le champ nom d'utilisateur
                            setTimeout(() => {
                                createWebShot(this.usernameGroup, () => {
                                    this.usernameGroup.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                    this.usernameGroup.style.opacity = '1';
                                    this.usernameGroup.style.transform = 'translateY(0)';
                                    
                                    // 4. Animer le champ mot de passe
                                    setTimeout(() => {
                                        createWebShot(this.passwordGroup, () => {
                                            this.passwordGroup.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                            this.passwordGroup.style.opacity = '1';
                                            this.passwordGroup.style.transform = 'translateY(0)';
                                            
                                            // 5. Animer le bouton de connexion
                                            setTimeout(() => {
                                                createWebShot(this.loginButton, () => {
                                                    this.loginButton.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                                    this.loginButton.style.opacity = '1';
                                                    this.loginButton.style.transform = 'translateY(0)';
                                                    
                                                    // 6. Animer le bouton de visibilité du mot de passe
                                                    setTimeout(() => {
                                                        createWebShot(this.passwordToggle, () => {
                                                            this.passwordToggle.style.transition = 'opacity 0.5s ease-in-out';
                                                            this.passwordToggle.style.opacity = '1';
                                                            
                                                            // Configuration terminée, démarrer les animations inactives
                                                            this.spiderManager.startIdleAnimations();
                                                        });
                                                    }, 800);
                                                });
                                            }, 800);
                                        });
                                    }, 800);
                                });
                            }, this.titleSpans.length * 300 + 500);
                        }, 1000);
                    });
                }
            }
            
// ===========================================
// INITIALISATION ET DÉMARRAGE
// ===========================================

// Initialiser l'application
async function initializeApplication() {
    try {
        // Créer et initialiser le gestionnaire de sprites d'icônes
        const iconManager = new IconSpriteManager(allIcons);
        await iconManager.initialize();
        
        // Créer le gestionnaire de toile d'araignée
        const spiderWebManager = new SpiderWebManager(iconManager);
        spiderWebManager.initialize();
        
        // Créer le gestionnaire de fond
        const backgroundManager = new BackgroundManager();
        
        // Créer le gestionnaire d'animation
        const animationManager = new AnimationManager();
        
        // Ajouter les callbacks d'update
        animationManager
            .addUpdateCallback(deltaTime => spiderWebManager.update(deltaTime))
            .addUpdateCallback(deltaTime => backgroundManager.update(deltaTime))
            .addDrawCallback(() => backgroundManager.draw())
            .addDrawCallback(() => spiderWebManager.draw());
        
        // Démarrer le gestionnaire d'animation
        animationManager.start();
        
        // Configurer le gestionnaire de redimensionnement
        window.addEventListener('resize', () => {
            resizeCanvases();
            spiderWebManager.resize();
            backgroundManager.resize();
        });
        
        // Configurer le suivi du curseur
        document.addEventListener('mousemove', (e) => {
            trackPupils(e);
        });
        
        // Configurer les événements pour les champs de formulaire
        username.addEventListener('input', () => {
            const rect = username.getBoundingClientRect();
            const x = rect.left + username.value.length * 8;
            const y = rect.top + rect.height / 2;
            
            trackPupils({ clientX: x, clientY: y });
        });
        
        // Basculement de visibilité du mot de passe
        passwordToggle.addEventListener('click', () => {
            if (password.type === 'password') {
                password.type = 'text';
                leftPupil.parentElement.style.height = '';
                rightPupil.parentElement.style.height = '';
            } else {
                password.type = 'password';
                if (document.activeElement === password) {
                    leftPupil.parentElement.style.height = '1px';
                    rightPupil.parentElement.style.height = '1px';
                }
            }
        });
        
        // Focus et blur pour le champ mot de passe
        password.addEventListener('focus', () => {
            if (password.type === 'password') {
                leftPupil.parentElement.style.height = '1px';
                rightPupil.parentElement.style.height = '1px';
            }
        });
        
        password.addEventListener('blur', () => {
            leftPupil.parentElement.style.height = '';
            rightPupil.parentElement.style.height = '';
        });
        
        // Configurer le clic sur l'araignée
        spider.addEventListener('click', () => {
            spider.style.transform = 'translateX(-50%) scale(0.9)';
            setTimeout(() => {
                spider.style.transform = 'translateX(-50%) scale(1)';
            }, 200);
            
            // Tirer une toile vers la caméra
            cameraWeb.style.opacity = '1';
            setTimeout(() => {
                cameraWeb.style.opacity = '0';
            }, 1000);
        });
        
        // Masquer l'écran de chargement
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
            loadingScreen.style.display = 'none';
        }, 500);
        
        // Position initiale de l'araignée
        spider.style.top = '-120px';
        
        // Séquence d'animation
        setTimeout(() => {
            // L'araignée descend
            spider.style.transition = 'top 2s ease-in-out';
            spider.style.top = '120px';
            
            // Après que l'araignée soit en position
            setTimeout(() => {
                // Tir de toile pour attirer le conteneur de connexion
                createWebShot(spider, loginContainer, () => {
                    loginContainer.style.transition = 'opacity 1s ease-in-out';
                    loginContainer.style.opacity = '1';
                    
                    // Après l'apparition du conteneur, démarrer l'animation du titre
                    setTimeout(() => {
                        titleSpans.forEach((span, index) => {
                            setTimeout(() => {
                                createWebShot(spider, span, () => {
                                    span.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                    span.style.opacity = '1';
                                    span.style.transform = 'translateY(0)';
                                });
                            }, index * 300);
                        });
                        
                        // Après l'animation du titre, attirer le champ nom d'utilisateur
                        setTimeout(() => {
                            createWebShot(spider, usernameGroup, () => {
                                usernameGroup.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                usernameGroup.style.opacity = '1';
                                usernameGroup.style.transform = 'translateY(0)';
                                
                                // Après le champ nom d'utilisateur, attirer le champ mot de passe
                                setTimeout(() => {
                                    createWebShot(spider, passwordGroup, () => {
                                        passwordGroup.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                        passwordGroup.style.opacity = '1';
                                        passwordGroup.style.transform = 'translateY(0)';
                                        
                                        // Après le champ mot de passe, attirer le bouton de connexion
                                        setTimeout(() => {
                                            createWebShot(spider, loginButton, () => {
                                                loginButton.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                                                loginButton.style.opacity = '1';
                                                loginButton.style.transform = 'translateY(0)';
                                                
                                                // Après le bouton de connexion, attirer le bouton de visibilité du mot de passe
                                                setTimeout(() => {
                                                    createWebShot(spider, passwordToggle, () => {
                                                        passwordToggle.style.transition = 'opacity 0.5s ease-in-out';
                                                        passwordToggle.style.opacity = '1';
                                                        
                                                        // La configuration est terminée, démarrer les animations inactives
                                                        setupIdleAnimations();
                                                    });
                                                }, 800);
                                            });
                                        }, 800);
                                    });
                                }, 800);
                            });
                        }, titleSpans.length * 300 + 500);
                    }, 1000);
                });
            }, 2000);
        }, 1000);
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation :', error);
        alert('Une erreur s\'est produite lors du chargement. Veuillez rafraîchir la page.');
    }
}

            
            // Démarrer l'application
            initializeApplication();
            
        });
    </script>
</body>
</html>
